<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Accord.Imaging</name>
    </assembly>
    <members>
        <member name="T:Accord.Imaging.Blob">
            <summary>
            Image's blob.
            </summary>
            
            <remarks><para>The class represents a blob - part of another images. The
            class encapsulates the blob itself and information about its position
            in parent image.</para>
            
            <para><note>The class is not responsible for blob's image disposing, so it should be
            done manually when it is required.</note></para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.Image">
             <summary>
             Blob's image.
             </summary>
            
             <remarks><para>The property keeps blob's image. In the case if it equals to <b>null</b>,
             the image may be extracted using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.OriginalSize">
            <summary>
            Blob's image size.
            </summary>
            
            <remarks><para>The property specifies size of the <see cref="P:Accord.Imaging.Blob.Image">blob's image</see>.
            If the property is set to <see langword="true"/>, the blob's image size equals to the
            size of original image. If the property is set to <see langword="false"/>, the blob's
            image size equals to size of actual blob.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.Rectangle">
            <summary>
            Blob's rectangle in the original image.
            </summary>
            
            <remarks><para>The property specifies position of the blob in the original image
            and its size.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.ID">
            <summary>
            Blob's ID in the original image.
            </summary>
        </member>
        <member name="P:Accord.Imaging.Blob.Area">
            <summary>
            Blob's area.
            </summary>
            
            <remarks><para>The property equals to blob's area measured in number of pixels
            contained by the blob.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.Fullness">
            <summary>
            Blob's fullness, [0, 1].
            </summary>
            
            <remarks><para>The property equals to blob's fullness, which is calculated
            as <b>Area / ( Width * Height )</b>. If it equals to <b>1</b>, then
            it means that entire blob's rectangle is filled by blob's pixel (no
            blank areas), which is true only for rectangles. If it equals to <b>0.5</b>,
            for example, then it means that only half of the bounding rectangle is filled
            by blob's pixels.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.CenterOfGravity">
            <summary>
            Blob's center of gravity point.
            </summary>
            
            <remarks><para>The property keeps center of gravity point, which is calculated as
            mean value of X and Y coordinates of blob's points.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.ColorMean">
            <summary>
            Blob's mean color.
            </summary>
            
            <remarks><para>The property keeps mean color of pixels comprising the blob.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.Blob.ColorStdDev">
            <summary>
            Blob color's standard deviation.
            </summary>
            
            <remarks><para>The property keeps standard deviation of pixels' colors comprising the blob.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Blob.#ctor(System.Int32,System.Drawing.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Blob"/> class.
            </summary>
            
            <param name="id">Blob's ID in the original image.</param>
            <param name="rect">Blob's rectangle in the original image.</param>
            
            <remarks><para>This constructor leaves <see cref="P:Accord.Imaging.Blob.Image"/> property not initialized. The blob's
            image may be extracted later using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.Blob.#ctor(Accord.Imaging.Blob)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.Blob"/> class.
            </summary>
            
            <param name="source">Source blob to copy.</param>
            
            <remarks><para>This copy constructor leaves <see cref="P:Accord.Imaging.Blob.Image"/> property not initialized. The blob's
            image may be extracted later using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.</para></remarks>
            
        </member>
        <member name="T:Accord.Imaging.BlobCounter">
            <summary>
            Blob counter - counts objects in image, which are separated by black background.
            </summary>
            
            <remarks><para>The class counts and extracts stand alone objects in
            images using connected components labeling algorithm.</para>
            
            <para><note>The algorithm treats all pixels with values less or equal to <see cref="P:Accord.Imaging.BlobCounter.BackgroundThreshold"/>
            as background, but pixels with higher values are treated as objects' pixels.</note></para>
            
            <para>For blobs' searching the class supports 8 bpp indexed grayscale images and
            24/32 bpp color images that are at least two pixels wide. Images that are one
            pixel wide can be processed if they are rotated first, or they can be processed
            with <see cref="T:Accord.Imaging.RecursiveBlobCounter"/>.
            See documentation about <see cref="T:Accord.Imaging.BlobCounterBase"/> for information about which
            pixel formats are supported for extraction of blobs.</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of blob counter algorithm
            BlobCounter bc = new BlobCounter( );
            // process binary image
            bc.ProcessImage( image );
            Rectangle[] rects = bc.GetObjectsRectangles( );
            // process blobs
            foreach ( Rectangle rect in rects )
            {
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounter.BackgroundThreshold">
             <summary>
             Background threshold's value.
             </summary>
             
             <remarks><para>The property sets threshold value for distinguishing between background
             pixel and objects' pixels. All pixel with values less or equal to this property are
             treated as background, but pixels with higher values are treated as objects' pixels.</para>
             
             <para><note>In the case of colour images a pixel is treated as objects' pixel if <b>any</b> of its
             RGB values are higher than corresponding values of this threshold.</note></para>
             
             <para><note>For processing grayscale image, set the property with all RGB components eqaul.</note></para>
            
             <para>Default value is set to <b>(0, 0, 0)</b> - black colour.</para></remarks>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="image">Image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="imageData">Image data to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounter"/> class.
            </summary>
            
            <param name="image">Unmanaged image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounter.BuildObjectsMap(Accord.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks>The method supports 8 bpp indexed grayscale images and 24/32 bpp color images.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Cannot process images that are one pixel wide. Rotate the image
            or use <see cref="T:Accord.Imaging.RecursiveBlobCounter"/>.</exception>
            
        </member>
        <member name="T:Accord.Imaging.ObjectsOrder">
            <summary>
            Possible object orders.
            </summary>
            
            <remarks>The enumeration defines possible sorting orders of objects, found by blob
            counting classes.</remarks>
            
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.None">
            <summary>
            Unsorted order (as it is collected by algorithm).
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.Size">
            <summary>
            Objects are sorted by size in descending order (bigger objects go first).
            Size is calculated as <b>Width * Height</b>.
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.Area">
            <summary>
            Objects are sorted by area in descending order (bigger objects go first).
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.YX">
            <summary>
            Objects are sorted by Y coordinate, then by X coordinate in ascending order
            (smaller coordinates go first).
            </summary>
        </member>
        <member name="F:Accord.Imaging.ObjectsOrder.XY">
            <summary>
            Objects are sorted by X coordinate, then by Y coordinate in ascending order
            (smaller coordinates go first).
            </summary>
        </member>
        <member name="T:Accord.Imaging.BlobCounterBase">
            <summary>
            Base class for different blob counting algorithms.
            </summary>
            
            <remarks><para>The class is abstract and serves as a base for different blob counting algorithms.
            Classes, which inherit from this base class, require to implement <see cref="M:Accord.Imaging.BlobCounterBase.BuildObjectsMap(Accord.Imaging.UnmanagedImage)"/>
            method, which does actual building of object's label's map.</para>
            
            <para>For blobs' searcing usually all inherited classes accept binary images, which are actually
            grayscale thresholded images. But the exact supported format should be checked in particular class,
            inheriting from the base class. For blobs' extraction the class supports grayscale (8 bpp indexed)
            and color images (24 and 32 bpp).</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of blob counter algorithm
            BlobCounterBase bc = new ...
            // set filtering options
            bc.FilterBlobs = true;
            bc.MinWidth  = 5;
            bc.MinHeight = 5;
            // process binary image
            bc.ProcessImage( image );
            Blob[] blobs = bc.GetObjects( image, false );
            // process blobs
            foreach ( Blob blob in blobs )
            {
                // ...
                // blob.Rectangle - blob's rectangle
                // blob.Image - blob's image
            }
            </code>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.BlobCounterBase.objectsCount">
            <summary>
            Objects count.
            </summary>
        </member>
        <member name="F:Accord.Imaging.BlobCounterBase.objectLabels">
            <summary>
            Objects' labels.
            </summary>
        </member>
        <member name="F:Accord.Imaging.BlobCounterBase.imageWidth">
            <summary>
            Width of processed image.
            </summary>
        </member>
        <member name="F:Accord.Imaging.BlobCounterBase.imageHeight">
            <summary>
            Height of processed image.
            </summary>
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ObjectsCount">
            <summary>
            Objects count.
            </summary>
            
            <remarks><para>Number of objects (blobs) found by <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/> method.
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ObjectLabels">
            <summary>
            Objects' labels.
            </summary>
            
            <remarks>The array of <b>width</b> * <b>height</b> size, which holds
            labels for all objects. Background is represented with <b>0</b> value,
            but objects are represented with labels starting from <b>1</b>.</remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.ObjectsOrder">
            <summary>
            Objects sort order.
            </summary>
            
            <remarks><para>The property specifies objects' sort order, which are provided
            by <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsRectangles"/>, <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation"/>, etc.
            </para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.FilterBlobs">
            <summary>
            Specifies if blobs should be filtered.
            </summary>
            
            <remarks><para>If the property is equal to <b>false</b>, then there is no any additional
            post processing after image was processed. If the property is set to <b>true</b>, then
            blobs filtering is done right after image processing routine. If <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter"/>
            is set, then custom blobs' filtering is done, which is implemented by user. Otherwise
            blobs are filtered according to dimensions specified in <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/>,
            <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>, <see cref="P:Accord.Imaging.BlobCounterBase.MaxWidth"/> and <see cref="P:Accord.Imaging.BlobCounterBase.MaxHeight"/> properties.</para>
            
            <para>Default value is set to <see langword="false"/>.</para></remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering">
            <summary>
            Specifies if size filetering should be coupled or not.
            </summary>
            
            <remarks><para>In uncoupled filtering mode, objects are filtered out in the case if
            their width is smaller than <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/> <b>or</b> height is smaller than 
            <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>. But in coupled filtering mode, objects are filtered out in
            the case if their width is smaller than <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/> <b>and</b> height is
            smaller than <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>. In both modes the idea with filtering by objects'
            maximum size is the same as filtering by objects' minimum size.</para>
            
            <para>Default value is set to <see langword="false"/>, what means uncoupled filtering by size.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MinWidth">
            <summary>
            Minimum allowed width of blob.
            </summary>
            
            <remarks><para>The property specifies minimum object's width acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MinHeight">
            <summary>
            Minimum allowed height of blob.
            </summary>
            
            <remarks><para>The property specifies minimum object's height acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MaxWidth">
            <summary>
            Maximum allowed width of blob.
            </summary>
            
            <remarks><para>The property specifies maximum object's width acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.MaxHeight">
            <summary>
            Maximum allowed height of blob.
            </summary>
            
            <remarks><para>The property specifies maximum object's height acceptable by blob counting
            routine and has power only when <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to
            <see langword="true"/> and <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter">custom blobs' filter</see> is
            set to <see langword="null"/>.</para>
            
            <para>See documentation to <see cref="P:Accord.Imaging.BlobCounterBase.CoupledSizeFiltering"/> for additional information.</para>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.BlobCounterBase.BlobsFilter">
            <summary>
            Custom blobs' filter to use.
            </summary>
            
            <remarks><para>The property specifies custom blobs' filtering routine to use. It has
            effect only in the case if <see cref="P:Accord.Imaging.BlobCounterBase.FilterBlobs"/> property is set to <see langword="true"/>.</para>
            
            <para><note>When custom blobs' filtering routine is set, it has priority over default filtering done
            with <see cref="P:Accord.Imaging.BlobCounterBase.MinWidth"/>, <see cref="P:Accord.Imaging.BlobCounterBase.MinHeight"/>, <see cref="P:Accord.Imaging.BlobCounterBase.MaxWidth"/> and <see cref="P:Accord.Imaging.BlobCounterBase.MaxHeight"/>.</note></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="image">Binary image to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/> method.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="imageData">Binary image data to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> method.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class.
            </summary>
            
            <param name="image">Unmanaged binary image to look for objects in.</param>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.BlobCounterBase"/> class with
            initialized objects map built by calling <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)">
            <summary>
            Build objects map.
            </summary>
            
            <param name="image">Source binary image.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Build objects map.
            </summary>
            
            <param name="imageData">Source binary image data.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)">
            <summary>
            Build object map from raw image data.
            </summary>
            
            <param name="image">Source unmanaged binary image data.</param>
            
            <remarks><para>Processes the image and builds objects map, which is used later to extracts blobs.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Thrown by some inherited classes if some image property other
            than the pixel format is not supported. See that class's documentation or the exception message for details.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjectsRectangles">
            <summary>
            Get objects' rectangles.
            </summary>
            
            <returns>Returns array of objects' rectangles.</returns>
            
            <remarks>The method returns array of objects rectangles. Before calling the
            method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will
            build objects map.</remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so objects' rectangles
            can not be collected.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation">
            <summary>
            Get objects' information.
            </summary>
            
            <returns>Returns array of partially initialized blobs (without <see cref="P:Accord.Imaging.Blob.Image"/> property initialized).</returns>
            
            <remarks><para>By the amount of provided information, the method is between <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsRectangles"/> and
            <see cref="M:Accord.Imaging.BlobCounterBase.GetObjects(Accord.Imaging.UnmanagedImage,System.Boolean)"/> methods. The method provides array of blobs without initialized their image.
            Blob's image may be extracted later using <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)"/>
            or <see cref="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)"/> method.
            </para></remarks>
            
            <example>
            <code>
            // create blob counter and process image
            BlobCounter bc = new BlobCounter( sourceImage );
            // specify sort order
            bc.ObjectsOrder = ObjectsOrder.Size;
            // get objects' information (blobs without image)
            Blob[] blobs = bc.GetObjectInformation( );
            // process blobs
            foreach ( Blob blob in blobs )
            {
                // check blob's properties
                if ( blob.Rectangle.Width > 50 )
                {
                    // the blob looks interesting, let's extract it
                    bc.ExtractBlobsImage( sourceImage, blob );
                }
            }
            </code>
            </example>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so objects' information
            can not be collected.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjects(System.Drawing.Bitmap,System.Boolean)">
             <summary>
             Get blobs.
             </summary>
             
             <param name="image">Source image to extract objects from.</param>
             
             <returns>Returns array of blobs.</returns>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method returns array of blobs. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so objects
             can not be collected.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetObjects(Accord.Imaging.UnmanagedImage,System.Boolean)">
             <summary>
             Get blobs.
             </summary>
             
             <param name="image">Source unmanaged image to extract objects from.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
             
             <returns>Returns array of blobs.</returns>
             
             <remarks><para>The method returns array of blobs. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
            
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so objects
             can not be collected.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(System.Drawing.Bitmap,Accord.Imaging.Blob,System.Boolean)">
             <summary>
             Extract blob's image.
             </summary>
             
             <param name="image">Source image to extract blob's image from.</param>
             <param name="blob">Blob which is required to be extracted.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method is used to extract image of partially initialized blob, which
             was provided by <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation"/> method. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so blob
             can not be extracted.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.ExtractBlobsImage(Accord.Imaging.UnmanagedImage,Accord.Imaging.Blob,System.Boolean)">
             <summary>
             Extract blob's image.
             </summary>
             
             <param name="image">Source unmanaged image to extract blob's image from.</param>
             <param name="blob">Blob which is required to be extracted.</param>
             <param name="extractInOriginalSize">Specifies size of blobs' image to extract.
             If set to <see langword="true"/> each blobs' image will have the same size as
             the specified image. If set to <see langword="false"/> each blobs' image will
             have the size of its blob.</param>
            
             <remarks><para>The method is used to extract image of partially initialized blob, which
             was provided by <see cref="M:Accord.Imaging.BlobCounterBase.GetObjectsInformation"/> method. Before calling the
             method, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>, <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/>
             or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/> method should be called, which will build
             objects map.</para>
             
             <para>The method supports 24/32 bpp color and 8 bpp indexed grayscale images.</para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the provided image.</exception>
             <exception cref="T:System.ApplicationException">No image was processed before, so blob
             can not be extracted.</exception>
             
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetBlobsLeftAndRightEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)">
            <summary>
            Get list of points on the left and right edges of the blob.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            <param name="leftEdge">List of points on the left edge of the blob.</param>
            <param name="rightEdge">List of points on the right edge of the blob.</param>
            
            <remarks><para>The method scans each line of the blob and finds the most left and the
            most right points for it adding them to appropriate lists. The method may be very
            useful in conjunction with different routines from <see cref="!:Accord.Math.Geometry"/>,
            which allow finding convex hull or quadrilateral's corners.</para>
            
            <para><note>Both lists of points are sorted by Y coordinate - points with smaller Y
            value go first.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetBlobsTopAndBottomEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)">
            <summary>
            Get list of points on the top and bottom edges of the blob.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            <param name="topEdge">List of points on the top edge of the blob.</param>
            <param name="bottomEdge">List of points on the bottom edge of the blob.</param>
            
            <remarks><para>The method scans each column of the blob and finds the most top and the
            most bottom points for it adding them to appropriate lists. The method may be very
            useful in conjunction with different routines from <see cref="!:Accord.Math.Geometry"/>,
            which allow finding convex hull or quadrilateral's corners.</para>
            
            <para><note>Both lists of points are sorted by X coordinate - points with smaller X
            value go first.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.GetBlobsEdgePoints(Accord.Imaging.Blob)">
            <summary>
            Get list of object's edge points.
            </summary>
            
            <param name="blob">Blob to collect edge points for.</param>
            
            <returns>Returns unsorted list of blob's edge points.</returns>
            
            <remarks><para>The method scans each row and column of the blob and finds the
            most top/bottom/left/right points. The method returns similar result as if results of
            both <see cref="M:Accord.Imaging.BlobCounterBase.GetBlobsLeftAndRightEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)"/> and <see cref="M:Accord.Imaging.BlobCounterBase.GetBlobsTopAndBottomEdges(Accord.Imaging.Blob,System.Collections.Generic.List{Accord.IntPoint}@,System.Collections.Generic.List{Accord.IntPoint}@)"/>
            methods were combined, but each edge point occurs only once in the list.</para>
            
            <para><note>Edge points in the returned list are not ordered. This makes the list unusable
            for visualization with methods, which draw polygon or poly-line. But the returned list
            can be used with such algorithms, like convex hull search, shape analyzer, etc.</note></para>
            </remarks>
            
            <exception cref="T:System.ApplicationException">No image was processed before, so blob
            can not be extracted.</exception>
            
        </member>
        <member name="M:Accord.Imaging.BlobCounterBase.BuildObjectsMap(Accord.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks><note>By the time this method is called bitmap's pixel format is not
            yet checked, so this should be done by the class inheriting from the base class.
            <see cref="F:Accord.Imaging.BlobCounterBase.imageWidth"/> and <see cref="F:Accord.Imaging.BlobCounterBase.imageHeight"/> members are initialized
            before the method is called, so these members may be used safely.</note></remarks>
            
        </member>
        <member name="T:Accord.Imaging.RGB">
            <summary>
            RGB components.
            </summary>
            
            <remarks><para>The class encapsulates <b>RGB</b> color components.</para>
            <para><note><see cref="T:System.Drawing.Imaging.PixelFormat">PixelFormat.Format24bppRgb</see>
            actually means BGR format.</note></para>
            </remarks>
            
        </member>
        <member name="F:Accord.Imaging.RGB.R">
            <summary>
            Index of red component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.G">
            <summary>
            Index of green component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.B">
            <summary>
            Index of blue component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.A">
            <summary>
            Index of alpha component for ARGB images.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Red">
            <summary>
            Red component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Green">
            <summary>
            Green component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Blue">
            <summary>
            Blue component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.RGB.Alpha">
            <summary>
            Alpha component.
            </summary>
        </member>
        <member name="P:Accord.Imaging.RGB.Color">
            <summary>
            <see cref="T:System.Drawing.Color">Color</see> value of the class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.RGB.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RGB"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.RGB.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RGB"/> class.
            </summary>
            
            <param name="red">Red component.</param>
            <param name="green">Green component.</param>
            <param name="blue">Blue component.</param>
            
        </member>
        <member name="M:Accord.Imaging.RGB.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RGB"/> class.
            </summary>
            
            <param name="red">Red component.</param>
            <param name="green">Green component.</param>
            <param name="blue">Blue component.</param>
            <param name="alpha">Alpha component.</param>
            
        </member>
        <member name="M:Accord.Imaging.RGB.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RGB"/> class.
            </summary>
            
            <param name="color">Initialize from specified <see cref="T:System.Drawing.Color">color.</see></param>
            
        </member>
        <member name="T:Accord.Imaging.HSL">
            <summary>
            HSL components.
            </summary>
            
            <remarks>The class encapsulates <b>HSL</b> color components.</remarks>
            
        </member>
        <member name="F:Accord.Imaging.HSL.Hue">
            <summary>
            Hue component.
            </summary>
            
            <remarks>Hue is measured in the range of [0, 359].</remarks>
            
        </member>
        <member name="F:Accord.Imaging.HSL.Saturation">
            <summary>
            Saturation component.
            </summary>
            
            <remarks>Saturation is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="F:Accord.Imaging.HSL.Luminance">
            <summary>
            Luminance value.
            </summary>
            
            <remarks>Luminance is measured in the range of [0, 1].</remarks>
            
        </member>
        <member name="M:Accord.Imaging.HSL.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HSL"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.HSL.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.HSL"/> class.
            </summary>
            
            <param name="hue">Hue component.</param>
            <param name="saturation">Saturation component.</param>
            <param name="luminance">Luminance component.</param>
            
        </member>
        <member name="M:Accord.Imaging.HSL.FromRGB(Accord.Imaging.RGB,Accord.Imaging.HSL)">
            <summary>
            Convert from RGB to HSL color space.
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            <param name="hsl">Destination color in <b>HSL</b> color space.</param>
            
            <remarks><para>See <a href="http://en.wikipedia.org/wiki/HSI_color_space#Conversion_from_RGB_to_HSL_or_HSV">HSL and HSV Wiki</a>
            for information about the algorithm to convert from RGB to HSL.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.HSL.FromRGB(Accord.Imaging.RGB)">
            <summary>
            Convert from RGB to HSL color space.
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            
            <returns>Returns <see cref="T:Accord.Imaging.HSL"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:Accord.Imaging.HSL.ToRGB(Accord.Imaging.HSL,Accord.Imaging.RGB)">
            <summary>
            Convert from HSL to RGB color space.
            </summary>
            
            <param name="hsl">Source color in <b>HSL</b> color space.</param>
            <param name="rgb">Destination color in <b>RGB</b> color space.</param>
            
        </member>
        <member name="M:Accord.Imaging.HSL.ToRGB">
            <summary>
            Convert the color to <b>RGB</b> color space.
            </summary>
            
            <returns>Returns <see cref="T:Accord.Imaging.RGB"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="T:Accord.Imaging.YCbCr">
            <summary>
            YCbCr components.
            </summary>
            
            <remarks>The class encapsulates <b>YCbCr</b> color components.</remarks>
            
        </member>
        <member name="F:Accord.Imaging.YCbCr.YIndex">
            <summary>
            Index of <b>Y</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.CbIndex">
            <summary>
            Index of <b>Cb</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.CrIndex">
            <summary>
            Index of <b>Cr</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.Y">
            <summary>
            <b>Y</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.Cb">
            <summary>
            <b>Cb</b> component.
            </summary>
        </member>
        <member name="F:Accord.Imaging.YCbCr.Cr">
            <summary>
            <b>Cr</b> component.
            </summary>
        </member>
        <member name="M:Accord.Imaging.YCbCr.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.YCbCr"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.YCbCr.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.YCbCr"/> class.
            </summary>
            
            <param name="y"><b>Y</b> component.</param>
            <param name="cb"><b>Cb</b> component.</param>
            <param name="cr"><b>Cr</b> component.</param>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.FromRGB(Accord.Imaging.RGB,Accord.Imaging.YCbCr)">
            <summary>
            Convert from RGB to YCbCr color space (Rec 601-1 specification). 
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            <param name="ycbcr">Destination color in <b>YCbCr</b> color space.</param>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.FromRGB(Accord.Imaging.RGB)">
            <summary>
            Convert from RGB to YCbCr color space (Rec 601-1 specification).
            </summary>
            
            <param name="rgb">Source color in <b>RGB</b> color space.</param>
            
            <returns>Returns <see cref="T:Accord.Imaging.YCbCr"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.ToRGB(Accord.Imaging.YCbCr,Accord.Imaging.RGB)">
            <summary>
            Convert from YCbCr to RGB color space.
            </summary>
            
            <param name="ycbcr">Source color in <b>YCbCr</b> color space.</param>
            <param name="rgb">Destination color in <b>RGB</b> color space.</param>
            
        </member>
        <member name="M:Accord.Imaging.YCbCr.ToRGB">
            <summary>
            Convert the color to <b>RGB</b> color space.
            </summary>
            
            <returns>Returns <see cref="T:Accord.Imaging.RGB"/> instance, which represents converted color value.</returns>
            
        </member>
        <member name="T:Accord.Imaging.UnsupportedImageFormatException">
            <summary>
            Unsupported image format exception.
            </summary>
            
            <remarks><para>The unsupported image format exception is thrown in the case when
            user passes an image of certain format to an image processing routine, which does
            not support the format. Check documentation of the image processing routine
            to discover which formats are supported by the routine.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnsupportedImageFormatException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.UnsupportedImageFormatException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Imaging.UnsupportedImageFormatException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnsupportedImageFormatException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="paramName">Name of the invalid parameter.</param>
            
        </member>
        <member name="T:Accord.Imaging.InvalidImagePropertiesException">
            <summary>
            Invalid image properties exception.
            </summary>
            
            <remarks><para>The invalid image properties exception is thrown in the case when
            user provides an image with certain properties, which are treated as invalid by
            particular image processing routine. Another case when this exception is
            thrown is the case when user tries to access some properties of an image (or
            of a recently processed image by some routine), which are not valid for that image.</para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.InvalidImagePropertiesException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
        </member>
        <member name="M:Accord.Imaging.InvalidImagePropertiesException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Imaging.InvalidImagePropertiesException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.InvalidImagePropertiesException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="paramName">Name of the invalid parameter.</param>
            
        </member>
        <member name="T:Accord.Imaging.IBlobsFilter">
             <summary>
             Interface for custom blobs' filters used for filtering blobs after
             blob counting.
             </summary>
             
             <remarks><para>The interface should be implemented by classes, which perform
             custom blobs' filtering different from default filtering implemented in
             <see cref="T:Accord.Imaging.BlobCounterBase"/>. See <see cref="P:Accord.Imaging.BlobCounterBase.BlobsFilter"/>
             for additional information.</para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.IBlobsFilter.Check(Accord.Imaging.Blob)">
             <summary>
             Check specified blob and decide if should be kept or not.
             </summary>
             
             <param name="blob">Blob to check.</param>
             
             <returns>Return <see langword="true"/> if the blob should be kept or
             <see langword="false"/> if it should be removed.</returns>
            
        </member>
        <member name="T:Accord.Imaging.Image">
            <summary>
            Core image relatad methods.
            </summary>
            
            <remarks>All methods of this class are static and represent general routines
            used by different image processing classes.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.IsGrayscale(System.Drawing.Bitmap)">
            <summary>
            Check if specified 8 bpp image is grayscale.
            </summary>
            
            <param name="image">Image to check.</param>
            
            <returns>Returns <b>true</b> if the image is grayscale or <b>false</b> otherwise.</returns>
            
            <remarks>The methods checks if the image is a grayscale image of 256 gradients.
            The method first examines if the image's pixel format is
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            and then it examines its palette to check if the image is grayscale or not.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.CreateGrayscaleImage(System.Int32,System.Int32)">
            <summary>
            Create and initialize new 8 bpp grayscale image.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            
            <returns>Returns the created grayscale image.</returns>
            
            <remarks>The method creates new 8 bpp grayscale image and initializes its palette.
            Grayscale image is represented as
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            image with palette initialized to 256 gradients of gray color.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.SetGrayscalePalette(System.Drawing.Bitmap)">
            <summary>
            Set pallete of the 8 bpp indexed image to grayscale.
            </summary>
            
            <param name="image">Image to initialize.</param>
            
            <remarks>The method initializes palette of
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            image with 256 gradients of gray color.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Provided image is not 8 bpp indexed image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Image.Clone(System.Drawing.Bitmap,System.Drawing.Imaging.PixelFormat)">
             <summary>
             Clone image.
             </summary>
             
             <param name="source">Source image.</param>
             <param name="format">Pixel format of result image.</param>
             
             <returns>Returns clone of the source image with specified pixel format.</returns>
            
             <remarks>The original <see cref="M:System.Drawing.Bitmap.Clone(System.Drawing.Rectangle,System.Drawing.Imaging.PixelFormat)">Bitmap.Clone()</see>
             does not produce the desired result - it does not create a clone with specified pixel format.
             More of it, the original method does not create an actual clone - it does not create a copy
             of the image. That is why this method was implemented to provide the functionality.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Image.Clone(System.Drawing.Bitmap)">
            <summary>
            Clone image.
            </summary>
            
            <param name="source">Source image.</param>
            
            <returns>Return clone of the source image.</returns>
            
            <remarks>The original <see cref="M:System.Drawing.Bitmap.Clone(System.Drawing.Rectangle,System.Drawing.Imaging.PixelFormat)">Bitmap.Clone()</see>
            does not produce the desired result - it does not create an actual clone (it does not create a copy
            of the image). That is why this method was implemented to provide the functionality.</remarks> 
            
        </member>
        <member name="M:Accord.Imaging.Image.Clone(System.Drawing.Imaging.BitmapData)">
             <summary>
             Clone image.
             </summary>
             
             <param name="sourceData">Source image data.</param>
            
             <returns>Clones image from source image data. The message does not clone pallete in the
             case if the source image has indexed pixel format.</returns>
             
        </member>
        <member name="M:Accord.Imaging.Image.FormatImage(System.Drawing.Bitmap@)">
             <summary>
             Format an image.
             </summary>
             
             <param name="image">Source image to format.</param>
             
             <remarks><para>Formats the image to one of the formats, which are supported
             by the <b>AForge.Imaging</b> library. The image is left untouched in the
             case if it is already of
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppArgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see> or
             <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppArgb</see>
             format or it is <see cref="M:Accord.Imaging.Image.IsGrayscale(System.Drawing.Bitmap)">grayscale</see>, otherwise the image
             is converted to <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see>
             format.</para>
             
             <para><note>The method is deprecated and <see cref="M:Accord.Imaging.Image.Clone(System.Drawing.Bitmap,System.Drawing.Imaging.PixelFormat)"/> method should
             be used instead with specifying desired pixel format.</note></para>
             </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.FromFile(System.String)">
            <summary>
            Load bitmap from file.
            </summary>
            
            <param name="fileName">File name to load bitmap from.</param>
            
            <returns>Returns loaded bitmap.</returns>
            
            <remarks><para>The method is provided as an alternative of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>
            method to solve the issues of locked file. The standard .NET's method locks the source file until
            image's object is disposed, so the file can not be deleted or overwritten. This method workarounds the issue and
            does not lock the source file.</para>
            
            <para>Sample usage:</para>
            <code>
            Bitmap image = Accord.Imaging.Image.FromFile( "test.jpg" );
            </code>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.Image.Convert16bppTo8bpp(System.Drawing.Bitmap)">
            <summary>
            Convert bitmap with 16 bits per plane to a bitmap with 8 bits per plane.
            </summary>
            
            <param name="bimap">Source image to convert.</param>
            
            <returns>Returns new image which is a copy of the source image but with 8 bits per plane.</returns>
            
            <remarks><para>The routine does the next pixel format conversions:
            <list type="bullet">
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale">Format16bppGrayScale</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format8bppIndexed">Format8bppIndexed</see> with grayscale palette;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb">Format48bppRgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format24bppRgb">Format24bppRgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppArgb">Format64bppArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb">Format32bppArgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppPArgb">Format64bppPArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppPArgb">Format32bppPArgb</see>.</item>
            </list>
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Invalid pixel format of the source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.Image.Convert8bppTo16bpp(System.Drawing.Bitmap)">
            <summary>
            Convert bitmap with 8 bits per plane to a bitmap with 16 bits per plane.
            </summary>
            
            <param name="bimap">Source image to convert.</param>
            
            <returns>Returns new image which is a copy of the source image but with 16 bits per plane.</returns>
            
            <remarks><para>The routine does the next pixel format conversions:
            <list type="bullet">
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format8bppIndexed">Format8bppIndexed</see> (grayscale palette assumed) to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale">Format16bppGrayScale</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format24bppRgb">Format24bppRgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format48bppRgb">Format48bppRgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppArgb">Format32bppArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppArgb">Format64bppArgb</see>;</item>
            <item><see cref="F:System.Drawing.Imaging.PixelFormat.Format32bppPArgb">Format32bppPArgb</see> to
            <see cref="F:System.Drawing.Imaging.PixelFormat.Format64bppPArgb">Format64bppPArgb</see>.</item>
            </list>
            </para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Invalid pixel format of the source image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.RecursiveBlobCounter">
            <summary>
            Blob counter based on recursion.
            </summary>
            
            <remarks><para>The class counts and extracts stand alone objects in
            images using recursive version of connected components labeling
            algorithm.</para>
            
            <para><note>The algorithm treats all pixels with values less or equal to <see cref="P:Accord.Imaging.RecursiveBlobCounter.BackgroundThreshold"/>
            as background, but pixels with higher values are treated as objects' pixels.</note></para>
            
            <para><note>Since this algorithm is based on recursion, it is
            required to be careful with its application to big images with big blobs,
            because in this case recursion will require big stack size and may lead
            to stack overflow. The recursive version may be applied (and may be even
            faster than <see cref="T:Accord.Imaging.BlobCounter"/>) to an image with small blobs -
            "star sky" image (or small cells, for example, etc).</note></para>
            
            <para>For blobs' searching the class supports 8 bpp indexed grayscale images and
            24/32 bpp color images. 
            See documentation about <see cref="T:Accord.Imaging.BlobCounterBase"/> for information about which
            pixel formats are supported for extraction of blobs.</para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of blob counter algorithm
            RecursiveBlobCounter bc = new RecursiveBlobCounter( );
            // process binary image
            bc.ProcessImage( image );
            Rectangle[] rects = bc.GetObjectsRectangles( );
            // process blobs
            foreach ( Rectangle rect in rects )
            {
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.RecursiveBlobCounter.BackgroundThreshold">
             <summary>
             Background threshold's value.
             </summary>
             
             <remarks><para>The property sets threshold value for distinguishing between background
             pixel and objects' pixels. All pixel with values less or equal to this property are
             treated as background, but pixels with higher values are treated as objects' pixels.</para>
             
             <para><note>In the case of colour images a pixel is treated as objects' pixel if <b>any</b> of its
             RGB values are higher than corresponding values of this threshold.</note></para>
             
             <para><note>For processing grayscale image, set the property with all RGB components eqaul.</note></para>
            
             <para>Default value is set to <b>(0, 0, 0)</b> - black colour.</para></remarks>
             
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <remarks>Creates new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class with
            an empty objects map. Before using methods, which provide information about blobs
            or extract them, the <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Bitmap)"/>,
            <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(System.Drawing.Imaging.BitmapData)"/> or <see cref="M:Accord.Imaging.BlobCounterBase.ProcessImage(Accord.Imaging.UnmanagedImage)"/>
            method should be called to collect objects map.</remarks>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor(System.Drawing.Bitmap)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="image">Image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="imageData">Image data to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.#ctor(Accord.Imaging.UnmanagedImage)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.RecursiveBlobCounter"/> class.
            </summary>
            
            <param name="image">Unmanaged image to look for objects in.</param>
            
        </member>
        <member name="M:Accord.Imaging.RecursiveBlobCounter.BuildObjectsMap(Accord.Imaging.UnmanagedImage)">
            <summary>
            Actual objects map building.
            </summary>
            
            <param name="image">Unmanaged image to process.</param>
            
            <remarks>The method supports 8 bpp indexed grayscale images and 24/32 bpp color images.</remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image.</exception>
            
        </member>
        <member name="T:Accord.Imaging.UnmanagedImage">
            <summary>
            Image in unmanaged memory.
            </summary>
            
            <remarks>
            <para>The class represents wrapper of an image in unmanaged memory. Using this class
            it is possible as to allocate new image in unmanaged memory, as to just wrap provided
            pointer to unmanaged memory, where an image is stored.</para>
            
            <para>Usage of unmanaged images is mostly beneficial when it is required to apply <b>multiple</b>
            image processing routines to a single image. In such scenario usage of .NET managed images 
            usually leads to worse performance, because each routine needs to lock managed image
            before image processing is done and then unlock it after image processing is done. Without
            these lock/unlock there is no way to get direct access to managed image's data, which means
            there is no way to do fast image processing. So, usage of managed images lead to overhead, which
            is caused by locks/unlock. Unmanaged images are represented internally using unmanaged memory
            buffer. This means that it is not required to do any locks/unlocks in order to get access to image
            data (no overhead).</para>
            
            <para>Sample usage:</para>
            <code>
            // sample 1 - wrapping .NET image into unmanaged without
            // making extra copy of image in memory
            BitmapData imageData = image.LockBits(
                new Rectangle( 0, 0, image.Width, image.Height ),
                ImageLockMode.ReadWrite, image.PixelFormat );
            
            try
            {
                UnmanagedImage unmanagedImage = new UnmanagedImage( imageData ) );
                // apply several routines to the unmanaged image
            }
            finally
            {
                image.UnlockBits( imageData );
            }
            
            
            // sample 2 - converting .NET image into unmanaged
            UnmanagedImage unmanagedImage = UnmanagedImage.FromManagedImage( image );
            // apply several routines to the unmanaged image
            ...
            // conver to managed image if it is required to display it at some point of time
            Bitmap managedImage = unmanagedImage.ToManagedImage( );
            </code>
            </remarks>
            
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.ImageData">
            <summary>
            Pointer to image data in unmanaged memory.
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Width">
            <summary>
            Image width in pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Height">
            <summary>
            Image height in pixels.
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.Stride">
            <summary>
            Image stride (line size in bytes).
            </summary>
        </member>
        <member name="P:Accord.Imaging.UnmanagedImage.PixelFormat">
            <summary>
            Image pixel format.
            </summary>
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.#ctor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnmanagedImage"/> class.
            </summary>
            
            <param name="imageData">Pointer to image data in unmanaged memory.</param>
            <param name="width">Image width in pixels.</param>
            <param name="height">Image height in pixels.</param>
            <param name="stride">Image stride (line size in bytes).</param>
            <param name="pixelFormat">Image pixel format.</param>
            
            <remarks><para><note>Using this constructor, make sure all specified image attributes are correct
            and correspond to unmanaged memory buffer. If some attributes are specified incorrectly,
            this may lead to exceptions working with the unmanaged memory.</note></para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.#ctor(System.Drawing.Imaging.BitmapData)">
            <summary>
            Initializes a new instance of the <see cref="T:Accord.Imaging.UnmanagedImage"/> class.
            </summary>
            
            <param name="bitmapData">Locked bitmap data.</param>
            
            <remarks><note>Unlike <see cref="M:Accord.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Imaging.BitmapData)"/> method, this constructor does not make
            copy of managed image. This means that managed image must stay locked for the time of using the instance
            of unamanged image.</note></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Finalize">
            <summary>
            Destroys the instance of the <see cref="T:Accord.Imaging.UnmanagedImage"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Dispose">
            <summary>
            Dispose the object.
            </summary>
            
            <remarks><para>Frees unmanaged resources used by the object. The object becomes unusable
            after that.</para>
            
            <par><note>The method needs to be called only in the case if unmanaged image was allocated
            using <see cref="M:Accord.Imaging.UnmanagedImage.Create(System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/> method. In the case if the class instance was created using constructor,
            this method does not free unmanaged memory.</note></par>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Dispose(System.Boolean)">
            <summary>
            Dispose the object.
            </summary>
            
            <param name="disposing">Indicates if disposing was initiated manually.</param>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Clone">
            <summary>
            Clone the unmanaged images.
            </summary>
            
            <returns>Returns clone of the unmanaged image.</returns>
            
            <remarks><para>The method does complete cloning of the object.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Copy(Accord.Imaging.UnmanagedImage)">
            <summary>
            Copy unmanaged image.
            </summary>
            
            <param name="destImage">Destination image to copy this image to.</param>
            
            <remarks><para>The method copies current unmanaged image to the specified image.
            Size and pixel format of the destination image must be exactly the same.</para></remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Destination image has different size or pixel format.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Create(System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)">
            <summary>
            Allocate new image in unmanaged memory.
            </summary>
            
            <param name="width">Image width.</param>
            <param name="height">Image height.</param>
            <param name="pixelFormat">Image pixel format.</param>
            
            <returns>Return image allocated in unmanaged memory.</returns>
            
            <remarks><para>Allocate new image with specified attributes in unmanaged memory.</para>
            
            <para><note>The method supports only
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format16bppGrayScale</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format24bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format32bppPArgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format48bppRgb</see>,
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppArgb</see> and
            <see cref="T:System.Drawing.Imaging.PixelFormat">Format64bppPArgb</see> pixel formats.
            In the case if <see cref="T:System.Drawing.Imaging.PixelFormat">Format8bppIndexed</see>
            format is specified, pallete is not not created for the image (supposed that it is
            8 bpp grayscale image).
            </note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format was specified.</exception>
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">Invalid image size was specified.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.ToManagedImage">
            <summary>
            Create managed image from the unmanaged.
            </summary>
            
            <returns>Returns managed copy of the unmanaged image.</returns>
            
            <remarks><para>The method creates a managed copy of the unmanaged image with the
            same size and pixel format (it calls <see cref="M:Accord.Imaging.UnmanagedImage.ToManagedImage(System.Boolean)"/> specifying
            <see langword="true"/> for the <b>makeCopy</b> parameter).</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.ToManagedImage(System.Boolean)">
            <summary>
            Create managed image from the unmanaged.
            </summary>
            
            <param name="makeCopy">Make a copy of the unmanaged image or not.</param>
            
            <returns>Returns managed copy of the unmanaged image.</returns>
            
            <remarks><para>If the <paramref name="makeCopy"/> is set to <see langword="true"/>, then the method
            creates a managed copy of the unmanaged image, so the managed image stays valid even when the unmanaged
            image gets disposed. However, setting this parameter to <see langword="false"/> creates a managed image which is
            just a wrapper around the unmanaged image. So if unmanaged image is disposed, the
            managed image becomes no longer valid and accessing it will generate an exception.</para></remarks>
            
            <exception cref="T:Accord.Imaging.InvalidImagePropertiesException">The unmanaged image has some invalid properties, which results
            in failure of converting it to managed image. This may happen if user used the
            <see cref="M:Accord.Imaging.UnmanagedImage.#ctor(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat)"/> constructor specifying some
            invalid parameters.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Bitmap)">
            <summary>
            Create unmanaged image from the specified managed image.
            </summary>
            
            <param name="image">Source managed image.</param>
            
            <returns>Returns new unmanaged image, which is a copy of source managed image.</returns>
            
            <remarks><para>The method creates an exact copy of specified managed image, but allocated
            in unmanaged memory.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.FromManagedImage(System.Drawing.Imaging.BitmapData)">
            <summary>
            Create unmanaged image from the specified managed image.
            </summary>
            
            <param name="imageData">Source locked image data.</param>
            
            <returns>Returns new unmanaged image, which is a copy of source managed image.</returns>
            
            <remarks><para>The method creates an exact copy of specified managed image, but allocated
            in unmanaged memory. This means that managed image may be unlocked right after call to this
            method.</para></remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of source image.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Collect8bppPixelValues(System.Collections.Generic.List{Accord.IntPoint})">
            <summary>
            Collect pixel values from the specified list of coordinates.
            </summary>
            
            <param name="points">List of coordinates to collect pixels' value from.</param>
            
            <returns>Returns array of pixels' values from the specified coordinates.</returns>
            
            <remarks><para>The method goes through the specified list of points and for each point retrievs
            corresponding pixel's value from the unmanaged image.</para>
            
            <para><note>For grayscale image the output array has the same length as number of points in the
            specified list of points. For color image the output array has triple length, containing pixels'
            values in RGB order.</note></para>
            
            <para><note>The method does not make any checks for valid coordinates and leaves this up to user.
            If specified coordinates are out of image's bounds, the result is not predictable (crash in most cases).
            </note></para>
            
            <para><note>This method is supposed for images with 8 bpp channels only (8 bpp grayscale image and
            24/32 bpp color images).</note></para>
            </remarks>
            
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. Use Collect16bppPixelValues() method for
            images with 16 bpp channels.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.CollectActivePixels">
            <summary>
            Collect coordinates of none black pixels in the image.
            </summary>
            
            <returns>Returns list of points, which have other than black color.</returns>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.CollectActivePixels(System.Drawing.Rectangle)">
             <summary>
             Collect coordinates of none black pixels within specified rectangle of the image.
             </summary>
             
             <param name="rect">Image's rectangle to process.</param>
             
             <returns>Returns list of points, which have other than black color.</returns>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixels(System.Collections.Generic.List{Accord.IntPoint},System.Drawing.Color)">
             <summary>
             Set pixels with the specified coordinates to the specified color.
             </summary>
             
             <param name="coordinates">List of points to set color for.</param>
             <param name="color">Color to set for the specified points.</param>
             
             <remarks><para><note>For images having 16 bpp per color plane, the method extends the specified color
             value to 16 bit by multiplying it by 256.</note></para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixel(Accord.IntPoint,System.Drawing.Color)">
             <summary>
             Set pixel with the specified coordinates to the specified color.
             </summary>
             
             <param name="point">Point's coordiates to set color for.</param>
             <param name="color">Color to set for the pixel.</param>
             
             <remarks><para>See <see cref="M:Accord.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Drawing.Color)"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            Set pixel with the specified coordinates to the specified color.
            </summary>
            
            <param name="x">X coordinate of the pixel to set.</param>
            <param name="y">Y coordinate of the pixel to set.</param>
            <param name="color">Color to set for the pixel.</param>
            
            <remarks><para><note>For images having 16 bpp per color plane, the method extends the specified color
            value to 16 bit by multiplying it by 256.</note></para>
            
            <para>For grayscale images this method will calculate intensity value based on the below formula:
            <code lang="none">
            0.2125 * Red + 0.7154 * Green + 0.0721 * Blue
            </code>
            </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.SetPixel(System.Int32,System.Int32,System.Byte)">
             <summary>
             Set pixel with the specified coordinates to the specified value.
             </summary>
            
             <param name="x">X coordinate of the pixel to set.</param>
             <param name="y">Y coordinate of the pixel to set.</param>
             <param name="value">Pixel value to set.</param>
             
             <remarks><para>The method sets all color components of the pixel to the specified value.
             If it is a grayscale image, then pixel's intensity is set to the specified value.
             If it is a color image, then pixel's R/G/B components are set to the same specified value
             (if an image has alpha channel, then it is set to maximum value - 255 or 65535).</para>
             
             <para><note>For images having 16 bpp per color plane, the method extends the specified color
             value to 16 bit by multiplying it by 256.</note></para>
             </remarks>
             
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.GetPixel(Accord.IntPoint)">
             <summary>
             Get color of the pixel with the specified coordinates.
             </summary>
             
             <param name="point">Point's coordiates to get color of.</param>
             
             <returns>Return pixel's color at the specified coordinates.</returns>
             
             <remarks><para>See <see cref="M:Accord.Imaging.UnmanagedImage.GetPixel(System.Int32,System.Int32)"/> for more information.</para></remarks>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.GetPixel(System.Int32,System.Int32)">
            <summary>
            Get color of the pixel with the specified coordinates.
            </summary>
            
            <param name="x">X coordinate of the pixel to get.</param>
            <param name="y">Y coordinate of the pixel to get.</param>
            
            <returns>Return pixel's color at the specified coordinates.</returns>
            
            <remarks>
            <para><note>In the case if the image has 8 bpp grayscale format, the method will return a color with
            all R/G/B components set to same value, which is grayscale intensity.</note></para>
            
            <para><note>The method supports only 8 bpp grayscale images and 24/32 bpp color images so far.</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">The specified pixel coordinate is out of image's bounds.</exception>
            <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Pixel format of this image is not supported by the method.</exception>
            
        </member>
        <member name="M:Accord.Imaging.UnmanagedImage.Collect16bppPixelValues(System.Collections.Generic.List{Accord.IntPoint})">
             <summary>
             Collect pixel values from the specified list of coordinates.
             </summary>
             
             <param name="points">List of coordinates to collect pixels' value from.</param>
             
             <returns>Returns array of pixels' values from the specified coordinates.</returns>
             
             <remarks><para>The method goes through the specified list of points and for each point retrievs
             corresponding pixel's value from the unmanaged image.</para>
             
             <para><note>For grayscale image the output array has the same length as number of points in the
             specified list of points. For color image the output array has triple length, containing pixels'
             values in RGB order.</note></para>
             
             <para><note>The method does not make any checks for valid coordinates and leaves this up to user.
             If specified coordinates are out of image's bounds, the result is not predictable (crash in most cases).
             </note></para>
             
             <para><note>This method is supposed for images with 16 bpp channels only (16 bpp grayscale image and
             48/64 bpp color images).</note></para>
             </remarks>
             
             <exception cref="T:Accord.Imaging.UnsupportedImageFormatException">Unsupported pixel format of the source image. Use Collect8bppPixelValues() method for
             images with 8 bpp channels.</exception>
            
        </member>
    </members>
</doc>
